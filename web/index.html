<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Extra-Dimensional Real-Time-Checkers</title>
<link rel="icon" type="image/x-icon" href="favicon.ico">
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; overflow: hidden; }

#container { display: flex; height: 100vh; }
#viewport { flex: 1; position: relative; }
#sidebar {
    width: 260px;
    background: #2a2a2a;
    color: white;
    padding: 20px;
    display: flex;
    flex-direction: column;
    gap: 10px;
}
#waitingCode {
    color:#ccc;
    font-size:18px;
    margin-top:-10px;
}

.stat-item { 
    padding: 8px 12px; 
    background: rgba(255,255,255,0.05); 
    border-radius: 4px;
    font-size: 14px;
}

button {
    width: 100%;
    padding: 12px;
    font-size: 15px;
    cursor: pointer;
    border: none;
    border-radius: 4px;
    background: #4a90e2;
    color: white;
    transition: background 0.2s;
}
button:hover:not(:disabled) { background: #357abd; }
button:disabled { background: #666; cursor: not-allowed; opacity: 0.6; }

.modal {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.92);
    display: none;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    z-index: 100;
    gap: 20px;
}
.modal.active { display: flex; }
.modal h1 { color: white; font-size: 32px; margin-bottom: 10px; }
.modal button { width: 220px; }
.modal input {
    width: 220px;
    padding: 12px;
    font-size: 15px;
    border: 1px solid #555;
    border-radius: 4px;
    background: #333;
    color: white;
}
</style>
</head>
<body>
<div id="container">
  <div id="viewport"></div>
  <div id="sidebar">
    <h2>3D Checkers</h2>
    <div class="stat-item" id="localName"></div>
    <div class="stat-item" id="remoteName"></div>
    <div class="stat-item">Color: <strong id="playerColor">-</strong></div>
    <div class="stat-item" id="gameIdDisplay"></div>
    <div class="stat-item" id="turnDisplay">Turn: Red</div>
    <div class="stat-item" id="redCount">Red: 0</div>
    <div class="stat-item" id="blackCount">Black: 0</div>
    <button id="newGameBtn">New Game</button>
    <button id="undoBtn">Undo Move</button>
  </div>
</div>

<!-- Modals -->
<div id="startupModal" class="modal active">
  <h1>Extra-Dimensional Real-Time-Checkers</h1>
  <button id="localBtn">Local Multiplayer</button>
  <button id="webrtcBtn">Online Multiplayer</button>
</div>

<div id="webrtcModal" class="modal">
  <h1>Online Mode</h1>
  <input id="displayName" placeholder="Enter a Name/Handle">
  <button id="publicBtn">Find Public Game</button>
  <button id="createPrivateBtn">Create Private Game</button>
  <input id="privateGameId" placeholder="Enter Private Game ID">
  <button id="joinPrivateBtn">Join Private Game</button>
  <button id="backBtn">Back</button>
</div>

<div id="waitingModal" class="modal">
  <h1>Waiting for opponent...</h1>
  <p id="waitingCode"></p>
</div>

<div id="disconnectedModal" class="modal">
  <h1>Opponent Disconnected</h1>
  <p style="color:#ccc">Returning to menu in 5 seconds...</p>
</div>

<div id="winModal" class="modal">
  <h1 id="winText">Game Over</h1>
  <button id="winNewGameBtn">New Game</button>
  <button id="winMainMenuBtn">Main Menu</button>
</div>

<script type="module">
import * as THREE from './three/three.module.js';
import { OrbitControls } from './three/OrbitControls.js';

// ==================== CONSTANTS ====================
const CONFIG = {
  BOARD: { LAYERS: 3, SIZE: 8, TILE_SIZE: 1, GAP: 1.5 },
  COLORS: { 
    DARK_TILE: 0x222222, 
    LIGHT_TILE: 0x888888,
    RED: 0xaa0000,
    BLACK: 0x000000,
    GOLD: 0xffd700,
    HIGHLIGHT: 0x0000ff,
    VALID_MOVE: 0x00ff00
  },
  WS_URL: 'wss://rtcheckers.graphichealer.com'
  //WS_URL: 'ws://localhost:3000'
};

// ==================== STATE ====================
const state = {
  game: {
    board: [],
    currentPlayer: 'r',
    selectedPiece: null,
    mustContinueJump: false,
    moveHistory: [],
    isMultiplayer: false,
    myColor: 'r'
  },
  network: {
    ws: null,
    pc: null,
    dataChannel: null,
    dataChannelReady: false,
    dataChannelQueue: [],
    pendingIceCandidates: [],
    isCaller: false,
    roomId: null,
    lastNewGameReqId: null,
    isRespondingToNewGame: false,
    isAutoResetting: false
  },
  player: {
    displayName: "",
    opponentName: ""
  },
  scene: {
    boardMeshes: [],
    pieceMeshes: {},
    outlineMesh: null,
    virtualMoves: []
  }
};

// ==================== DOM REFERENCES ====================
const dom = {
  viewport: document.getElementById('viewport'),
  turnDisplay: document.getElementById('turnDisplay'),
  redCount: document.getElementById('redCount'),
  blackCount: document.getElementById('blackCount'),
  playerColor: document.getElementById('playerColor'),
  localName: document.getElementById('localName'),
  remoteName: document.getElementById('remoteName'),
  gameIdDisplay: document.getElementById('gameIdDisplay'),
  newGameBtn: document.getElementById('newGameBtn'),
  undoBtn: document.getElementById('undoBtn'),
  waitingCode: document.getElementById('waitingCode'),
  
  modals: {
    startup: document.getElementById('startupModal'),
    webrtc: document.getElementById('webrtcModal'),
    waiting: document.getElementById('waitingModal'),
    disconnected: document.getElementById('disconnectedModal'),
    win: document.getElementById('winModal')
  },
  
  buttons: {
    local: document.getElementById('localBtn'),
    webrtc: document.getElementById('webrtcBtn'),
    displayName: document.getElementById('displayName'),
    public: document.getElementById('publicBtn'),
    createPrivate: document.getElementById('createPrivateBtn'),
    joinPrivate: document.getElementById('joinPrivateBtn'),
    privateInput: document.getElementById('privateGameId'),
    back: document.getElementById('backBtn'),
    winNewGame: document.getElementById('winNewGameBtn'),
    winMainMenu: document.getElementById('winMainMenuBtn')
  },
  
  winText: document.getElementById('winText')
};

// ==================== THREE.JS SETUP ====================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x202020);

const camera = new THREE.PerspectiveCamera(
  60, 
  dom.viewport.clientWidth / dom.viewport.clientHeight, 
  0.1, 
  1000
);
camera.position.set(8, 12, 16);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(dom.viewport.clientWidth, dom.viewport.clientHeight);
dom.viewport.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.target.set(3.5, 0, 3.5);
controls.update();

scene.add(new THREE.AmbientLight(0xffffff, 0.5));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(10, 20, 10);
scene.add(dirLight);

// Shared geometries and materials
const geometries = {
  piece: new THREE.CylinderGeometry(0.4, 0.4, 0.2, 32),
  tile: new THREE.BoxGeometry(CONFIG.BOARD.TILE_SIZE, 0.1, CONFIG.BOARD.TILE_SIZE),
  kingBand: new THREE.TorusGeometry(0.25, 0.03, 16, 100),
  validMove: new THREE.CylinderGeometry(0.35, 0.35, 0.15, 32)
};

const materials = {
  red: new THREE.MeshPhongMaterial({ color: CONFIG.COLORS.RED }),
  black: new THREE.MeshPhongMaterial({ color: CONFIG.COLORS.BLACK }),
  gold: new THREE.MeshPhongMaterial({ color: CONFIG.COLORS.GOLD }),
  validMove: new THREE.MeshPhongMaterial({ 
    color: CONFIG.COLORS.VALID_MOVE, 
    transparent: true, 
    opacity: 0.5 
  })
};

// ==================== UTILITY FUNCTIONS ====================
const utils = {
  inBounds(l, r, c) {
    return l >= 0 && l < CONFIG.BOARD.LAYERS && 
           r >= 0 && r < CONFIG.BOARD.SIZE && 
           c >= 0 && c < CONFIG.BOARD.SIZE;
  },
  
  isValidTile(l, r, c) {
    return (l + r + c) % 2 === 0;
  },
  
  getPieceMeshKey(l, r, c) {
    return `${l}_${r}_${c}`;
  },
  
  showModal(modalName) {
    Object.values(dom.modals).forEach(m => m.classList.remove('active'));
    dom.modals[modalName]?.classList.add('active');
  },
  
  hideAllModals() {
    Object.values(dom.modals).forEach(m => m.classList.remove('active'));
  }
};

// ==================== BOARD MANAGEMENT ====================
const board = {
  create() {
    state.game.board = [];
    
    // Clean up existing meshes
    state.scene.boardMeshes.forEach(mesh => {
      scene.remove(mesh);
      mesh.geometry.dispose();
      mesh.material.dispose();
    });
    state.scene.boardMeshes = [];
    
    for (let l = 0; l < CONFIG.BOARD.LAYERS; l++) {
      const layer = [];
      for (let r = 0; r < CONFIG.BOARD.SIZE; r++) {
        const row = [];
        for (let c = 0; c < CONFIG.BOARD.SIZE; c++) {
          const isDark = (r + c + l) % 2 === 0;
          const material = new THREE.MeshPhongMaterial({
            color: isDark ? CONFIG.COLORS.DARK_TILE : CONFIG.COLORS.LIGHT_TILE,
            transparent: true,
            opacity: 0.7
          });
          
          const tile = new THREE.Mesh(geometries.tile, material);
          tile.position.set(c, l * CONFIG.BOARD.GAP, r);
          tile.userData = { boardCoord: { l, r, c } };
          scene.add(tile);
          state.scene.boardMeshes.push(tile);
          
          row.push(null);
        }
        layer.push(row);
      }
      state.game.board.push(layer);
    }
  }
};

// ==================== PIECE MANAGEMENT ====================
const pieces = {
  setup() {
    this.clearAll();
    
    // Red pieces (bottom layer)
    for (let r = 5; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        if ((r + c + 2) % 2 === 0) {
          this.create('r', CONFIG.BOARD.LAYERS - 1, r, c);
        }
      }
    }
    
    // Black pieces (top layer)
    for (let r = 0; r < 3; r++) {
      for (let c = 0; c < 8; c++) {
        if ((r + c + 2) % 2 === 0) {
          this.create('b', 0, r, c);
        }
      }
    }
    
    ui.updateSidebar();
  },
  
  create(color, l, r, c) {
    const material = color === 'r' ? materials.red : materials.black;
    const mesh = new THREE.Mesh(geometries.piece, material);
    mesh.position.set(c, l * CONFIG.BOARD.GAP + 0.15, r);
    mesh.userData.boardCoord = { l, r, c };
    scene.add(mesh);
    
    state.game.board[l][r][c] = { c: color, king: false };
    state.scene.pieceMeshes[utils.getPieceMeshKey(l, r, c)] = mesh;
  },
  
  clearAll() {
    Object.values(state.scene.pieceMeshes).forEach(mesh => {
      this.removeKingBand(mesh);
      scene.remove(mesh);
      mesh.geometry.dispose();
      mesh.material.dispose();
    });
    state.scene.pieceMeshes = {};
  },
  
  addKingBand(mesh) {
    if (mesh.userData.kingBand) return;
    const band = new THREE.Mesh(geometries.kingBand, materials.gold);
    band.rotation.x = Math.PI / 2;
    band.position.y = 0.1;
    mesh.add(band);
    mesh.userData.kingBand = band;
  },
  
  removeKingBand(mesh) {
    if (!mesh.userData.kingBand) return;
    mesh.remove(mesh.userData.kingBand);
    mesh.userData.kingBand.geometry.dispose();
    mesh.userData.kingBand.material.dispose();
    mesh.userData.kingBand = null;
  },
  
  getMesh(l, r, c) {
    return state.scene.pieceMeshes[utils.getPieceMeshKey(l, r, c)];
  }
};

// ==================== MOVE LOGIC ====================
const moves = {
  getValidMoves(l, r, c, onlyJumps = false) {
    const piece = state.game.board[l][r][c];
    if (!piece || piece.c !== state.game.currentPlayer) return [];
    
    const validMoves = [];
    const layerOffsets = [-1, 0, 1];
    const rowOffsets = piece.king ? [-1, 0, 1] : [piece.c === 'r' ? -1 : 1, 0];
    const colOffsets = [-1, 0, 1];
    
    for (let dl of layerOffsets) {
      for (let dr of rowOffsets) {
        for (let dc of colOffsets) {
          if (dl === 0 && dr === 0 && dc === 0) continue;
          
          const nl = l + dl, nr = r + dr, nc = c + dc;
          if (!utils.inBounds(nl, nr, nc) || !utils.isValidTile(nl, nr, nc)) continue;
          
          const target = state.game.board[nl][nr][nc];
          
          // Simple move
          if (!target && !onlyJumps) {
            validMoves.push({ 
              from: { l, r, c }, 
              to: { l: nl, r: nr, c: nc }, 
              captures: [] 
            });
          }
          // Jump move
          else if (target && target.c !== piece.c) {
            const jl = nl + dl, jr = nr + dr, jc = nc + dc;
            if (utils.inBounds(jl, jr, jc) && !state.game.board[jl][jr][jc]) {
              validMoves.push({ 
                from: { l, r, c }, 
                to: { l: jl, r: jr, c: jc }, 
                captures: [{ l: nl, r: nr, c: nc }] 
              });
            }
          }
        }
      }
    }
    
    const jumpMoves = validMoves.filter(m => m.captures.length > 0);
    return jumpMoves.length > 0 ? jumpMoves : (onlyJumps ? [] : validMoves);
  },
  
  execute(move, sendToRemote = true, isRemote = false) {
    // Only restrict moves in multiplayer mode
    if (state.game.isMultiplayer && !isRemote && 
        state.game.currentPlayer !== state.game.myColor) return;
    
    const { from, to } = move;
    const piece = state.game.board[from.l][from.r][from.c];
    if (!piece) return;
    
    // Save for undo
    const undoEntry = {
      from: { ...from },
      to: { ...to },
      piece: { ...piece },
      captured: move.captures.map(cap => {
        const cp = state.game.board[cap.l][cap.r][cap.c];
        return cp ? { color: cp.c, king: cp.king, l: cap.l, r: cap.r, c: cap.c } : null;
      }).filter(Boolean)
    };
    state.game.moveHistory.push(undoEntry);
    
    // Check for king promotion
    if (piece.c === 'r' && to.l === 0 && to.r === 0) piece.king = true;
    if (piece.c === 'b' && to.l === CONFIG.BOARD.LAYERS - 1 && to.r === 7) piece.king = true;
    
    const mesh = pieces.getMesh(from.l, from.r, from.c);
    if (piece.king && mesh && !mesh.userData.kingBand) {
      pieces.addKingBand(mesh);
    }
    
    // Move piece
    state.game.board[to.l][to.r][to.c] = piece;
    state.game.board[from.l][from.r][from.c] = null;
    
    // Remove captured pieces
    move.captures.forEach(cap => {
      const capMesh = pieces.getMesh(cap.l, cap.r, cap.c);
      if (capMesh) {
        pieces.removeKingBand(capMesh);
        scene.remove(capMesh);
        capMesh.geometry.dispose();
        capMesh.material.dispose();
        delete state.scene.pieceMeshes[utils.getPieceMeshKey(cap.l, cap.r, cap.c)];
        state.game.board[cap.l][cap.r][cap.c] = null;
      }
    });
    
    // Update mesh position
    if (mesh) {
      mesh.position.set(to.c, to.l * CONFIG.BOARD.GAP + 0.15, to.r);
      mesh.userData.boardCoord = { ...to };
      delete state.scene.pieceMeshes[utils.getPieceMeshKey(from.l, from.r, from.c)];
      state.scene.pieceMeshes[utils.getPieceMeshKey(to.l, to.r, to.c)] = mesh;
    }
    
    visual.clearHighlights();
    
    // Check for continued jumps
    const furtherJumps = this.getValidMoves(to.l, to.r, to.c, true);
    if (furtherJumps.length > 0 && move.captures.length > 0) {
      state.game.mustContinueJump = true;
      state.game.selectedPiece = { ...to };
      visual.highlightPiece(to.l, to.r, to.c);
    } else {
      state.game.mustContinueJump = false;
      state.game.selectedPiece = null;
      
      if (game.checkWin(isRemote)) return;
      
      state.game.currentPlayer = state.game.currentPlayer === 'r' ? 'b' : 'r';
    }
    
    ui.updateSidebar();
    
    // Send to opponent
    if (state.game.isMultiplayer && sendToRemote && !isRemote) {
      network.sendMove(move, state.game.currentPlayer);
    }
  },
  
  undo() {
    if (state.game.moveHistory.length === 0) return;
    
    const last = state.game.moveHistory.pop();
    const mesh = pieces.getMesh(last.to.l, last.to.r, last.to.c);
    
    if (mesh) {
      state.game.board[last.from.l][last.from.r][last.from.c] = last.piece;
      state.game.board[last.to.l][last.to.r][last.to.c] = null;
      mesh.position.set(last.from.c, last.from.l * CONFIG.BOARD.GAP + 0.15, last.from.r);
      mesh.userData.boardCoord = { ...last.from };
      delete state.scene.pieceMeshes[utils.getPieceMeshKey(last.to.l, last.to.r, last.to.c)];
      state.scene.pieceMeshes[utils.getPieceMeshKey(last.from.l, last.from.r, last.from.c)] = mesh;
      
      if (last.piece.king) pieces.addKingBand(mesh);
      else pieces.removeKingBand(mesh);
    }
    
    // Restore captured pieces
    last.captured.forEach(cap => {
      const material = cap.c === 'r' ? materials.red : materials.black;
      const capMesh = new THREE.Mesh(geometries.piece, material);
      capMesh.position.set(cap.c, cap.l * CONFIG.BOARD.GAP + 0.15, cap.r);
      capMesh.userData.boardCoord = { l: cap.l, r: cap.r, c: cap.c };
      scene.add(capMesh);
      state.game.board[cap.l][cap.r][cap.c] = { c: cap.color, king: cap.king };
      if (cap.king) pieces.addKingBand(capMesh);
      state.scene.pieceMeshes[utils.getPieceMeshKey(cap.l, cap.r, cap.c)] = capMesh;
    });
    
    visual.clearHighlights();
    state.game.mustContinueJump = false;
    state.game.selectedPiece = null;
    state.game.currentPlayer = state.game.currentPlayer === 'r' ? 'b' : 'r';
    ui.updateSidebar();
  }
};

// ==================== VISUAL EFFECTS ====================
const visual = {
  clearHighlights() {
    if (state.scene.outlineMesh) {
      scene.remove(state.scene.outlineMesh);
      state.scene.outlineMesh.geometry.dispose();
      state.scene.outlineMesh.material.dispose();
      state.scene.outlineMesh = null;
    }
    
    state.scene.virtualMoves.forEach(vm => {
      scene.remove(vm);
      vm.geometry.dispose();
      vm.material.dispose();
    });
    state.scene.virtualMoves = [];
  },
  
  highlightPiece(l, r, c) {
    this.clearHighlights();
    
    const mesh = pieces.getMesh(l, r, c);
    if (!mesh) return;
    
    const edges = new THREE.EdgesGeometry(mesh.geometry);
    state.scene.outlineMesh = new THREE.LineSegments(
      edges,
      new THREE.LineBasicMaterial({ color: CONFIG.COLORS.HIGHLIGHT, linewidth: 2 })
    );
    state.scene.outlineMesh.position.copy(mesh.position);
    state.scene.outlineMesh.rotation.copy(mesh.rotation);
    scene.add(state.scene.outlineMesh);
    
    const validMoves = moves.getValidMoves(l, r, c, state.game.mustContinueJump);
    validMoves.forEach(move => {
      const vm = new THREE.Mesh(geometries.validMove, materials.validMove);
      vm.position.set(move.to.c, move.to.l * CONFIG.BOARD.GAP + 0.15, move.to.r);
      vm.userData.move = move;
      scene.add(vm);
      state.scene.virtualMoves.push(vm);
    });
  }
};

// ==================== GAME LOGIC ====================
const game = {
  reset() {
    state.game.currentPlayer = 'r';
    state.game.mustContinueJump = false;
    state.game.selectedPiece = null;
    state.game.moveHistory = [];
    pieces.clearAll();
    visual.clearHighlights();
    board.create();
    pieces.setup();
  },
  
  checkWin(isRemote = false) {
    let redCount = 0, blackCount = 0;
    
    for (let l = 0; l < CONFIG.BOARD.LAYERS; l++) {
      for (let r = 0; r < CONFIG.BOARD.SIZE; r++) {
        for (let c = 0; c < CONFIG.BOARD.SIZE; c++) {
          const p = state.game.board[l][r][c];
          if (p) {
            if (p.c === 'r') redCount++;
            else blackCount++;
          }
        }
      }
    }
    
    ui.updateSidebar();
    
    if (redCount === 0) {
      this.showWinScreen('b', isRemote);
      if (state.game.isMultiplayer && !isRemote) network.sendWin('b');
      return true;
    }
    
    if (blackCount === 0) {
      this.showWinScreen('r', isRemote);
      if (state.game.isMultiplayer && !isRemote) network.sendWin('r');
      return true;
    }
    
    return false;
  },
  
  showWinScreen(winner, isRemote = false) {
    let text;
    if (state.game.isMultiplayer) {
      text = winner === state.game.myColor ? "You Won! ðŸŽ‰" : `${state.player.opponentName} Wins! ðŸ†`;
    } else {
      text = winner === 'r' ? "Red Wins!" : "Black Wins!";
    }
    
    dom.winText.textContent = text;
    utils.showModal('win');
    dom.undoBtn.style.display = 'none';
  }
};

// ==================== UI ====================
const ui = {
  updateNames() {
    dom.localName.textContent = `You: ${state.player.displayName}`;
    dom.remoteName.textContent = state.player.opponentName 
      ? `Opponent: ${state.player.opponentName}`
      : "Waiting for Opponent...";
  },

  updateSidebar() {
    dom.turnDisplay.textContent = `Turn: ${state.game.currentPlayer === 'r' ? 'Red' : 'Black'}`;
    
    let redCount = 0, blackCount = 0;
    for (let l = 0; l < CONFIG.BOARD.LAYERS; l++) {
      for (let r = 0; r < CONFIG.BOARD.SIZE; r++) {
        for (let c = 0; c < CONFIG.BOARD.SIZE; c++) {
          const p = state.game.board[l][r][c];
          if (p) {
            if (p.c === 'r') redCount++;
            else blackCount++;
          }
        }
      }
    }
    
    dom.redCount.textContent = `Red: ${redCount}`;
    dom.blackCount.textContent = `Black: ${blackCount}`;
    
    ui.updateNames();
  },
  
  resetNewGameButtons() {
    [dom.newGameBtn, dom.buttons.winNewGame].forEach(btn => {
      btn.disabled = false;
      btn.style.backgroundColor = '';
      btn.textContent = 'New Game';
    });
  },
  
  showNewGamePrompt() {
    dom.newGameBtn.style.backgroundColor = '#d9534f';
    dom.newGameBtn.textContent = 'Opponent wants new game - Click to confirm';
    dom.newGameBtn.disabled = false;
    state.network.isRespondingToNewGame = true;
    
    setTimeout(() => {
      if (state.network.isRespondingToNewGame) {
        state.network.isRespondingToNewGame = false;
        dom.newGameBtn.textContent = 'New Game';
        dom.newGameBtn.style.backgroundColor = '';
        dom.newGameBtn.disabled = false;
      }
    }, 15000);
  }
};

// ==================== NETWORK ====================
const network = {
  connectWebSocket() {
    state.network.ws = new WebSocket(CONFIG.WS_URL);
    
    state.network.ws.addEventListener('open', () => {
      console.log('WebSocket connected');
    });
    
    state.network.ws.addEventListener('message', async msg => {
      const data = JSON.parse(msg.data);
      await this.handleMessage(data);
    });
  },
  
  async handleMessage(data) {
    switch (data.type) {
      case 'ice':
        await this.handleIceCandidate(data.candidate);
        break;
        
      case 'opponentRequestedNewGame':
        if (data.reqId && data.reqId === state.network.lastNewGameReqId) return;
        ui.showNewGamePrompt();
        break;
        
      case 'startNewGame':
        state.network.isAutoResetting = true;
        dom.newGameBtn.disabled = false;
        dom.newGameBtn.style.backgroundColor = '';
        dom.newGameBtn.textContent = 'New Game';
        state.network.lastNewGameReqId = null;
        game.reset();
        ui.resetNewGameButtons();
        setTimeout(() => { state.network.isAutoResetting = false; }, 500);
        break;
        
      case 'opponentDisconnected':
        utils.showModal('disconnected');
        setTimeout(() => {
          utils.showModal('startup');
          dom.undoBtn.style.display = 'block';
          state.game.isMultiplayer = false;
          game.reset();
        }, 5000);
        break;
      case 'roomCreated':
        // Server sent back the new private room code
        state.network.roomId = data.roomId;
        utils.showModal('waiting');
        dom.waitingCode.textContent = `Join Code: ${data.roomId}`;
        break;

      case 'waitingForOpponent':
        // Player is waiting in queue or room
        utils.showModal('waiting');
        dom.waitingCode.textContent = '';
        break;
      
      case 'matchFound':
      case 'startGame':
        // Match found or opponent joined â€” start the game
        utils.hideAllModals();
        state.game.isMultiplayer = true;
        state.game.myColor = data.isCaller ? 'r' : 'b';
        dom.playerColor.textContent = state.game.myColor === 'r' ? 'Red' : 'Black';
        game.reset();
        
        // ðŸŸ¢ Store names
        state.player.opponentName = data.opponentName || "Opponent";
        ui.updateNames();
        
        // Begin WebRTC connection setup
        state.network.isCaller = data.isCaller || false;
        state.network.roomId = data.roomId;
        network.setupPeerConnection();
        break;

      case 'offer':
        await state.network.pc.setRemoteDescription(new RTCSessionDescription(data.offer));
        const answer = await state.network.pc.createAnswer();
        await state.network.pc.setLocalDescription(answer);
        state.network.ws.send(JSON.stringify({
          type: 'answer',
          answer,
          roomId: state.network.roomId
        }));
        break;

      case 'answer':
        await state.network.pc.setRemoteDescription(new RTCSessionDescription(data.answer));
        await network.flushPendingIceCandidates();
        break;
    }
  },

  setupPeerConnection() {
    if (state.network.pc) return;
    
    state.network.pc = new RTCPeerConnection({
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    });
    
    state.network.pc.onicecandidate = e => {
      if (e.candidate) {
        state.network.ws.send(JSON.stringify({ 
          type: 'ice', 
          candidate: e.candidate, 
          roomId: state.network.roomId 
        }));
      }
    };
    
    state.network.pc.ondatachannel = event => {
      state.network.dataChannel = event.channel;
      this.setupDataChannel();
    };
    
    if (state.network.isCaller) {
      state.network.dataChannel = state.network.pc.createDataChannel('game');
      this.setupDataChannel();
      
      state.network.pc.createOffer()
        .then(offer => state.network.pc.setLocalDescription(offer))
        .then(() => {
          state.network.ws.send(JSON.stringify({ 
            type: 'offer', 
            offer: state.network.pc.localDescription, 
            roomId: state.network.roomId 
          }));
        });
    }
  },
  
  async handleIceCandidate(candidate) {
    if (!candidate) return;
    if (!state.network.pc || !state.network.pc.remoteDescription) {
      state.network.pendingIceCandidates.push(candidate);
      return;
    }
    try {
      await state.network.pc.addIceCandidate(candidate);
    } catch (err) {
      console.error('Error adding ICE candidate:', err);
    }
  },
  
  async flushPendingIceCandidates() {
    if (!state.network.pc || !state.network.pendingIceCandidates.length) return;
    
    for (const candidate of state.network.pendingIceCandidates) {
      try {
        await state.network.pc.addIceCandidate(candidate);
      } catch (err) {
        console.error('Error flushing ICE candidate:', err);
      }
    }
    state.network.pendingIceCandidates = [];
  },
  
  setupDataChannel() {
    state.network.dataChannel.onopen = () => {
      state.network.dataChannelReady = true;
      while (state.network.dataChannelQueue.length > 0) {
        state.network.dataChannel.send(state.network.dataChannelQueue.shift());
      }
    };
    
    state.network.dataChannel.onmessage = e => {
      const payload = JSON.parse(e.data);
      
      if (payload.type === 'move') {
        moves.execute(payload.move, false, true);
        if (!game.checkWin(true)) {
          state.game.currentPlayer = payload.nextTurn;
        }
        ui.updateSidebar();
      } else if (payload.type === 'win') {
        game.showWinScreen(payload.winner, true);
        state.game.currentPlayer = null;
      }
    };
    
    state.network.dataChannel.onclose = () => {
      state.network.dataChannelReady = false;
    };
  },
  
  sendMove(move, nextTurn) {
    const payload = { type: 'move', move, nextTurn };
    const msg = JSON.stringify(payload);
    
    if (state.network.dataChannel && state.network.dataChannelReady) {
      state.network.dataChannel.send(msg);
    } else {
      state.network.dataChannelQueue.push(msg);
    }
  },
  
  sendWin(winner) {
    if (state.network.dataChannel && state.network.dataChannelReady) {
      state.network.dataChannel.send(JSON.stringify({ type: 'win', winner }));
    }
  },
  
  requestNewGame(button = dom.newGameBtn) {
    if (state.network.isAutoResetting) return;
    
    if (state.network.isRespondingToNewGame) {
      if (state.network.ws && state.network.ws.readyState === WebSocket.OPEN) {
        state.network.ws.send(JSON.stringify({ 
          type: 'readyForNewGame', 
          roomId: state.network.roomId 
        }));
      }
      button.textContent = 'Confirming...';
      button.disabled = true;
      button.style.backgroundColor = '#888';
      state.network.isRespondingToNewGame = false;
      return;
    }
    
    if (state.game.isMultiplayer && state.network.ws && 
        state.network.ws.readyState === WebSocket.OPEN) {
      const reqId = Math.random().toString(36).substring(2, 8);
      state.network.lastNewGameReqId = reqId;
      
      state.network.ws.send(JSON.stringify({ 
        type: 'readyForNewGame', 
        roomId: state.network.roomId, 
        reqId 
      }));
      
      button.style.backgroundColor = '#888';
      button.textContent = 'Waiting for opponent...';
      button.disabled = true;
    } else {
      game.reset();
    }
  }
};

// ==================== INTERACTION ====================
const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();

function onClick(event) {
  // Only restrict clicks in multiplayer mode
  if (state.game.isMultiplayer && state.game.currentPlayer !== state.game.myColor) return;
  
  const rect = dom.viewport.getBoundingClientRect();
  pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
  
  raycaster.setFromCamera(pointer, camera);
  const intersects = raycaster.intersectObjects(scene.children, true);
  
  if (intersects.length === 0) return;
  
  for (const hit of intersects) {
    const obj = hit.object;
    
    // Click on valid move indicator
    if (obj.userData.move) {
      moves.execute(obj.userData.move);
      return;
    }
    
    // Click on piece
    if (obj.userData.boardCoord) {
      const { l, r, c } = obj.userData.boardCoord;
      
      if (state.game.mustContinueJump && 
          state.game.selectedPiece && 
          (state.game.selectedPiece.l !== l || 
           state.game.selectedPiece.r !== r || 
           state.game.selectedPiece.c !== c)) {
        return;
      }
      
      const piece = state.game.board[l][r][c];
      if (!piece || piece.c !== state.game.currentPlayer) return;
      
      if (state.game.selectedPiece && 
          state.game.selectedPiece.l === l && 
          state.game.selectedPiece.r === r && 
          state.game.selectedPiece.c === c) {
        state.game.selectedPiece = null;
        visual.clearHighlights();
      } else {
        state.game.selectedPiece = { l, r, c };
        visual.highlightPiece(l, r, c);
      }
      return;
    }
  }
}

// ==================== EVENT LISTENERS ====================
dom.viewport.addEventListener('pointerdown', onClick);

window.addEventListener('resize', () => {
  camera.aspect = dom.viewport.clientWidth / dom.viewport.clientHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(dom.viewport.clientWidth, dom.viewport.clientHeight);
});

// Menu buttons
dom.buttons.local.addEventListener('click', () => {
  utils.hideAllModals();
  dom.undoBtn.style.display = 'block';
  dom.gameIdDisplay.style.display = 'none';
  dom.remoteName.style.display = 'none';
  dom.localName.style.display = 'none';
  state.game.isMultiplayer = false;
  state.game.currentPlayer = 'r';
});

dom.buttons.webrtc.addEventListener('click', () => {
  utils.showModal('webrtc');
  dom.undoBtn.style.display = 'none';
  state.game.isMultiplayer = true;
});

dom.buttons.back.addEventListener('click', () => {
  utils.showModal('startup');
});

dom.buttons.public.addEventListener('click', () => {
  const name = dom.buttons.displayName.value.trim();
  if (!name) return alert('Please enter a Name/Handle');
  state.player.displayName = name;
  utils.showModal('waiting');
  dom.waitingCode.textContent = '';
  dom.gameIdDisplay.style.display = 'none';
  network.connectWebSocket();
  state.network.ws.addEventListener('open', () => {
    state.network.ws.send(JSON.stringify({ type: 'joinPublic', displayName: name }));
  });
});

dom.buttons.createPrivate.addEventListener('click', () => {
  const name = dom.buttons.displayName.value.trim();
  if (!name) return alert('Please enter a Name/Handle');
  state.player.displayName = name;
  const id = Math.random().toString(36).substring(2, 8);
  dom.gameIdDisplay.textContent = `Game ID: ${id}`;
  dom.waitingCode.textContent = `Game ID: ${id}`;
  utils.showModal('waiting');
  network.connectWebSocket();
  state.network.ws.addEventListener('open', () => {
    state.network.ws.send(JSON.stringify({ type: 'createPrivate', roomId: id, displayName: name }));
  });
});

dom.buttons.joinPrivate.addEventListener('click', () => {
  const name = dom.buttons.displayName.value.trim();
  if (!name) return alert('Please enter a Name/Handle');
  state.player.displayName = name;
  const id = dom.buttons.privateInput.value.trim();
  if (!id) return alert('Please enter a Game ID');
  dom.waitingCode.textContent = `Joining Room: ${id}`
  dom.gameIdDisplay.textContent = `Game ID: ${id}`;
  utils.showModal('waiting');
  network.connectWebSocket();
  state.network.ws.addEventListener('open', () => {
    state.network.ws.send(JSON.stringify({ type: 'joinPrivate', roomId: id, displayName: name }));
  });
});

dom.newGameBtn.addEventListener('click', () => {
  network.requestNewGame(dom.newGameBtn);
});

dom.undoBtn.addEventListener('click', () => {
  moves.undo();
});

dom.buttons.winNewGame.addEventListener('click', () => {
  utils.hideAllModals();
  network.requestNewGame(dom.buttons.winNewGame);
});

dom.buttons.winMainMenu.addEventListener('click', () => {
  utils.showModal('startup');
  dom.undoBtn.style.display = 'block';
  ui.resetNewGameButtons();
  state.game.isMultiplayer = false;
  state.game.currentPlayer = 'r';
  game.reset();
});

// ==================== ANIMATION LOOP ====================
function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}

// ==================== INITIALIZATION ====================
board.create();
pieces.setup();
animate();
</script>
</body>
</html>



