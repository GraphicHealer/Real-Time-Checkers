<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Real-Time-Checkers</title>
<link id="favicon" rel="icon" type="image/png" href="">
<audio id="moveSfx" src="audio/move.mp3" preload="auto"></audio>
<audio id="captureSfx" src="audio/capture.mp3" preload="auto"></audio>
<audio id="kingSfx" src="audio/king.mp3" preload="auto"></audio>
<audio id="winSfx" src="audio/win.mp3" preload="auto"></audio>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
  overflow: hidden;
}

#container {
  display: flex;
  height: 100vh; 
}

#viewport {
  flex: 1;
  min-width: 0;
  position: relative;
}
#sidebar {
  width: 260px;
  background: #2a2a2a;
  color: white;
  padding: 20px;
  display: flex;
  flex-direction: column;
  flex-shrink: 0;
  gap: 10px;
}
#waitingCode {
  color:#ccc;
  font-size:18px;
  margin-top:-10px;
  text-align: center;
}
#joinCode {
  font-size: 30px;
  padding: 8px 12px;
  border-radius: 4px;
  background: #2a2a2a;
}
#sidebarButtons {
  margin-top: auto;   /* push entire button group to the bottom */
  display: flex;
  flex-direction: column;
  gap: 10px;
}
#playerList {
  display: flex;
  flex-direction: column;
  gap: 15px;
  margin-top: 10px;
}

button {
  width: 100%;
  padding: 12px;
  font-size: 15px;
  cursor: pointer;
  border: none;
  border-radius: 4px;
  background: #4a90e2;
  color: white;
  transition: background 0.2s;
}
button:hover:not(:disabled) { background: #357abd; }
button:disabled { background: #666; cursor: not-allowed; opacity: 0.6; }

.stat-item { 
  padding: 8px 12px; 
  background: rgba(255,255,255,0.05); 
  border-radius: 4px;
  font-size: 14px;
}

.modal {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0);
  display: none;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  text-align: center;
  z-index: 100;
  gap: 20px;
}
.modal.active { display: flex; }
.modal h1 { color: white; font-size: 32px; margin-bottom: 10px; }
.modal button { width: 220px; }
.modal input {
  width: 220px;
  padding: 12px;
  font-size: 15px;
  border: 1px solid #555;
  border-radius: 4px;
  background: #333;
  color: white;
}

.player-profile {
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 10px;
  border-radius: 6px;
  background: rgba(255,255,255,0.05);
  transition: all 0.3s ease;
}

.player-profile.active {
  background: rgba(255,255,255,0.15);
  box-shadow: 0 0 10px rgba(255,255,255,0.2);
}

.checker-piece {
  width: 32px;
  height: 32px;
  border-radius: 50%;
  border: 2px solid #888;
}

.checker-piece.red {
  background: radial-gradient(circle at 30% 30%, #ff4b4b, #aa0000);
}

.checker-piece.black {
  background: radial-gradient(circle at 30% 30%, #555, #000);
}

.player-name {
  font-size: 16px;
  font-weight: 600;
}

/* === Mobile-Friendly Sidebar (players stacked over buttons) === */
@media (max-width: 700px) {
  /* Sidebar moves below game */
  #container {
    flex-direction: column; /* sidebar below viewport */
  }

  #sidebar {
    width: 100%;
    flex-direction: column; /* stack contents vertically */
    align-items: center;
    justify-content: center;
    padding: 10px 15px;
    border-top: 2px solid #333;
    gap: 10px;
    position: sticky;
    bottom: 0;
    z-index: 10;
  }

  /* Hide the title */
  #sidebar h2 {
    display: none;
  }

  /* Players section */
  #playerList {
    flex-direction: row; /* players side-by-side */
    justify-content: center;
    gap: 12px;
    width: 100%;
  }

  .player-profile {
    flex: 1;
    justify-content: center;
    padding: 6px 8px;
    background: rgba(255,255,255,0.05);
  }

  /* Buttons section */
  #sidebarButtons {
    flex-direction: row;
    justify-content: center;
    gap: 10px;
    width: 100%;
  }

  #newGameBtn,
  #undoBtn {
    flex: 1;
    padding: 10px;
  }

  /* Optional: faint divider line between players and buttons */
  #sidebarButtons {
    border-top: 1px solid rgba(255,255,255,0.1);
    padding-top: 6px;
  }

  /* Optional: subtle shadow above bottom bar */
  #sidebar::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 10px;
    background: linear-gradient(to bottom, rgba(0,0,0,0.4), transparent);
    pointer-events: none;
  }
}

#helpButton {
  position: absolute;
  bottom: 20px;
  left: 20px;
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background: #4a90e2;
  color: white;
  font-size: 24px;
  font-weight: bold;
  cursor: pointer;
  border: none;
  box-shadow: 0 4px 8px rgba(0,0,0,0.3);
  z-index: 50;
  transition: all 0.2s;
}

#helpButton:hover { background: #357abd; transform: scale(1.1); }

#viewToggle {
  position: absolute;
  bottom: 20px;
  right: 20px;
  width: 50px;
  height: 50px;
  border-radius: 50%;
  background: #4a90e2;
  color: white;
  font-size: 24px;
  cursor: pointer;
  border: none;
  box-shadow: 0 4px 8px rgba(0,0,0,0.3);
  z-index: 50;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
}

#viewToggle:hover {
  background: #357abd;
  transform: scale(1.1);
}

.help-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0,0,0,0.85);
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 99;
  padding: 20px;
}

.help-overlay.active { display: flex; }

.help-content {
  background: #2a2a2a;
  color: white;
  padding: 30px;
  border-radius: 10px;
  max-width: 500px;
  max-height: 80vh;
  overflow-y: auto;
}

.help-content h2 { margin-bottom: 20px; color: #4a90e2; }
.help-content h3 { margin-top: 20px; margin-bottom: 10px; color: #6ab0ff; }
.help-content p { margin: 8px 0; line-height: 1.6; }
.help-content .control-item { padding: 8px 0; border-bottom: 1px solid rgba(255,255,255,0.1); }
.help-close { margin-top: 20px; width: 100%; padding: 12px; background: #4a90e2; color: white; border: none; border-radius: 4px; font-size: 15px; cursor: pointer; }

/* Mobile adjustments */
@media (max-width: 700px) {
  #helpButton { bottom: 10px; left: 10px; width: 45px; height: 45px; font-size: 20px; }
  #viewToggle { bottom: 10px; right: 10px; width: 45px; height: 45px; font-size: 20px; }
}
</style>
</head>
<body>
<div id="container">
  <div id="viewport">
    <button id="helpButton" title="Help">
      <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="margin: -1px 0 0 -1px;">
        <circle cx="12" cy="12" r="10"></circle>
        <path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path>
        <line x1="12" y1="17" x2="12.01" y2="17"></line>
      </svg>
    </button>
    <button id="viewToggle" title="Toggle View">
      <svg width="28" height="28" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
        <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
        <circle cx="12" cy="12" r="3"></circle>
      </svg>
    </button>
  </div>
  <div id="sidebar">
    <h2>3D Checkers</h2>
    <div id="playerList">
      <div class="player-profile" id="playerRed">
        <div class="checker-piece red"></div>
        <div class="player-name" id="redName">Red Player</div>
      </div>
      <div class="player-profile" id="playerBlack">
        <div class="checker-piece black"></div>
        <div class="player-name" id="blackName">Black Player</div>
      </div>
    </div>
    <div id="sidebarButtons">
      <button id="newGameBtn">New Game</button>
      <button id="undoBtn">Undo Move</button>
    </div>
  </div>
</div>

<!-- Help Overlay -->
<div id="helpOverlay" class="help-overlay">
  <div class="help-content">
    <h2>Game Controls</h2>
    <div id="desktopControls">
      <h3>Desktop Controls</h3>
      <div class="control-item"><strong>Click + Drag:</strong> Rotate camera around board</div>
      <div class="control-item"><strong>Right Click + Drag:</strong> Pan camera</div>
      <div class="control-item"><strong>Scroll Wheel:</strong> Zoom in/out</div>
      <div class="control-item"><strong>Click on Piece:</strong> Select piece and show valid moves</div>
      <div class="control-item"><strong>Click on Green Indicator:</strong> Move to that position</div>
    </div>
    <div id="mobileControls" style="display:none;">
      <h3>Mobile Controls</h3>
      <div class="control-item"><strong>One Finger Drag:</strong> Rotate camera around board</div>
      <div class="control-item"><strong>Two Finger Drag:</strong> Pan camera</div>
      <div class="control-item"><strong>Pinch:</strong> Zoom in/out</div>
      <div class="control-item"><strong>Tap on Piece:</strong> Select piece and show valid moves</div>
      <div class="control-item"><strong>Tap on Green Indicator:</strong> Move to that position</div>
    </div>
    <h3>How to Play</h3>
    <div class="control-item">Move pieces diagonally across all three layers. Jump over opponent pieces to capture them. Reach the opposite corner to become a king and move in any direction!</div>
    <button class="help-close" id="helpClose">Close</button>
  </div>
</div>

<!-- Modals -->
<div id="startupModal" class="modal active">
  <h1>Extra&#x2011;Dimensional Real&#x2011;Time&#x2011;Checkers</h1>
  <button id="localBtn">Local Multiplayer</button>
  <button id="webrtcBtn">Online Multiplayer</button>
</div>

<div id="webrtcModal" class="modal">
  <h1>Online Mode</h1>
  <input id="displayName" placeholder="Enter a Name/Handle">
  <button id="publicBtn">Find Public Game</button>
  <button id="privateBtn">Private Game</button>
  <button id="backBtn">Back</button>
</div>

<div id="privateModal" class="modal">
  <h1>Private Game</h1>
  <button id="createPrivateBtn">Create Private Game</button>
  <input id="privateGameId" placeholder="Enter Private Game ID">
  <button id="joinPrivateBtn">Join Private Game</button>
  <button id="backToOnlineBtn">Back</button>
</div>

<div id="waitingModal" class="modal">
  <h1>Waiting for opponent...</h1>
  <p id="waitingCode"></p>
</div>

<div id="disconnectedModal" class="modal">
  <h1>Opponent Disconnected</h1>
  <p style="color:#ccc">Returning to menu in 5 seconds...</p>
</div>

<div id="winModal" class="modal">
  <h1 id="winText">Game Over</h1>
  <button id="winNewGameBtn">New Game</button>
  <button id="winMainMenuBtn">Main Menu</button>
</div>

<script type="module">
import * as THREE from './three/three.module.js';
import { OrbitControls } from './three/OrbitControls.js';

// ==================== CONSTANTS ====================
const CONFIG = {
  VIEW_MODE: '3D', // '3D' or '2D'
  BOARD: { LAYERS: 1, SIZE: 8, TILE_SIZE: 1, GAP: 1.5 },
  COLORS: {
    WOOD: 0x8B4513,
    DARK_TILE: 0x225522, 
    LIGHT_TILE: 0x888888,
    RED: 0xaa0000,
    BLACK: 0x000000,
    GOLD: 0xffd700,
    HIGHLIGHT: 0x0000ff,
    VALID_MOVE: 0x00ff00
  },
  WS_URL: 'wss://rtcheckers.graphichealer.com'
  //WS_URL: 'ws://localhost:3000'
};

// ==================== STATE ====================
const state = {
  game: {
    board: [],
    currentPlayer: 'r',
    selectedPiece: null,
    mustContinueJump: false,
    moveHistory: [],
    isMultiplayer: false,
    myColor: 'r'
  },
  network: {
    ws: null,
    pc: null,
    dataChannel: null,
    dataChannelReady: false,
    dataChannelQueue: [],
    pendingIceCandidates: [],
    isCaller: false,
    roomId: null,
    lastNewGameReqId: null,
    isRespondingToNewGame: false,
    isAutoResetting: false
  },
  player: {
    displayName: "",
    opponentName: ""
  },
  scene: {
    boardMeshes: [],
    pieceMeshes: {},
    outlineMesh: null,
    virtualMoves: [],
    framePosts: [],  // ADD THIS
    baseBoard: null
  }
};

// ==================== DOM REFERENCES ====================
const dom = {
  viewport: document.getElementById('viewport'),
  redName: document.getElementById('redName'),
  blackName: document.getElementById('blackName'),
  redProfile: document.getElementById('playerRed'),
  blackProfile: document.getElementById('playerBlack'),
  newGameBtn: document.getElementById('newGameBtn'),
  undoBtn: document.getElementById('undoBtn'),
  waitingCode: document.getElementById('waitingCode'),
  
  modals: {
    startup: document.getElementById('startupModal'),
    webrtc: document.getElementById('webrtcModal'),
    private: document.getElementById('privateModal'),
    waiting: document.getElementById('waitingModal'),
    disconnected: document.getElementById('disconnectedModal'),
    win: document.getElementById('winModal')
  },
  
  buttons: {
    local: document.getElementById('localBtn'),
    webrtc: document.getElementById('webrtcBtn'),
    displayName: document.getElementById('displayName'),
    public: document.getElementById('publicBtn'),
    private: document.getElementById('privateBtn'),
    backToOnline: document.getElementById('backToOnlineBtn'),
    createPrivate: document.getElementById('createPrivateBtn'),
    joinPrivate: document.getElementById('joinPrivateBtn'),
    privateInput: document.getElementById('privateGameId'),
    back: document.getElementById('backBtn'),
    winNewGame: document.getElementById('winNewGameBtn'),
    winMainMenu: document.getElementById('winMainMenuBtn')
  },
  
  helpButton: document.getElementById('helpButton'),
  helpOverlay: document.getElementById('helpOverlay'),
  helpClose: document.getElementById('helpClose'),
  viewToggle: document.getElementById('viewToggle'),
  desktopControls: document.getElementById('desktopControls'),
  mobileControls: document.getElementById('mobileControls'),
  
  winText: document.getElementById('winText'),
  
  sfx: {
    move: document.getElementById('moveSfx'),
    capture: document.getElementById('captureSfx'),
    king: document.getElementById('kingSfx'),
    win: document.getElementById('winSfx')
  }
};

// ==================== THREE.JS SETUP ====================
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x202020);

const camera = new THREE.PerspectiveCamera(
  60, 
  dom.viewport.clientWidth / dom.viewport.clientHeight, 
  0.1, 
  1000
);
camera.position.set(8, 12, 16);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(dom.viewport.clientWidth, dom.viewport.clientHeight);
dom.viewport.appendChild(renderer.domElement);

const controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true;
controls.target.set(3.5, 0, 3.5);
controls.update();

scene.add(new THREE.AmbientLight(0xffffff, 0.5));
const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
dirLight.position.set(10, 20, 10);
scene.add(dirLight);

// Shared geometries and materials
const geometries = {
  piece: new THREE.CylinderGeometry(0.4, 0.4, 0.2, 32),
  tile: new THREE.BoxGeometry(CONFIG.BOARD.TILE_SIZE, 0.1, CONFIG.BOARD.TILE_SIZE),
  kingBand: new THREE.TorusGeometry(0.25, 0.03, 16, 100),
  validMove: new THREE.CylinderGeometry(0.35, 0.35, 0.15, 32)
};

const materials = {
  red: new THREE.MeshPhongMaterial({ color: CONFIG.COLORS.RED }),
  black: new THREE.MeshPhongMaterial({ color: CONFIG.COLORS.BLACK }),
  gold: new THREE.MeshPhongMaterial({ color: CONFIG.COLORS.GOLD }),
  validMove: new THREE.MeshPhongMaterial({ 
    color: CONFIG.COLORS.VALID_MOVE, 
    transparent: true, 
    opacity: 0.5 
  }),
  wood: new THREE.MeshPhongMaterial({  // ADD THIS
    color: CONFIG.COLORS.WOOD,
    shininess: 30
  })
};

// ==================== UTILITY FUNCTIONS ====================
const utils = {
  inBounds(l, r, c) {
    return l >= 0 && l < CONFIG.BOARD.LAYERS && 
           r >= 0 && r < CONFIG.BOARD.SIZE && 
           c >= 0 && c < CONFIG.BOARD.SIZE;
  },
  
  isValidTile(l, r, c) {
    return (l + r + c) % 2 === 0;
  },
  
  getPieceMeshKey(l, r, c) {
    return `${l}_${r}_${c}`;
  },
  
  showModal(modalName) {
    Object.values(dom.modals).forEach(m => m.classList.remove('active'));
    dom.modals[modalName]?.classList.add('active');
  },
  
  hideAllModals() {
    Object.values(dom.modals).forEach(m => m.classList.remove('active'));
  },
  
  setFavicon(color, isWinner = false) {
    const canvas = document.createElement("canvas");
    const size = 64;
    canvas.width = size;
    canvas.height = size;
    const ctx = canvas.getContext("2d");

    // --- Checker geometry ---
    const topY = 18;
    const height = 18;
    const radiusX = 24;
    const radiusY = 10;

    // --- Base colors ---
    const baseColor = color === "red" || color === "#ff4b4b" ? "#c62828" : "#111";
    const sideColor = color === "red" || color === "#ff4b4b" ? "#8b1a1a" : "#000";
    const edgeHighlight = color === "red" || color === "#ff4b4b" ? "#ff6b6b" : "#444";

    // --- Shadow below the piece ---
    ctx.beginPath();
    ctx.ellipse(size / 2, topY + height + 6, radiusX, radiusY * 0.8, 0, 0, Math.PI * 2);
    ctx.fillStyle = "rgba(0,0,0,0.25)";
    ctx.fill();

    // --- Side gradient ---
    const gradient = ctx.createLinearGradient(0, topY, 0, topY + height);
    gradient.addColorStop(0, baseColor);
    gradient.addColorStop(1, sideColor);

    ctx.beginPath();
    ctx.ellipse(size / 2, topY, radiusX, radiusY, 0, Math.PI, 0, true); // hidden top arc
    ctx.ellipse(size / 2, topY + height, radiusX, radiusY, 0, 0, Math.PI, false); // bottom arc
    ctx.closePath();
    ctx.fillStyle = gradient;
    ctx.fill();

    // --- Top face ---
    const topGrad = ctx.createRadialGradient(
      size * 0.45, topY - 2, 2,
      size / 2, topY, radiusX
    );
    topGrad.addColorStop(0, edgeHighlight);
    topGrad.addColorStop(1, baseColor);

    ctx.beginPath();
    ctx.ellipse(size / 2, topY, radiusX, radiusY, 0, 0, Math.PI * 2);
    ctx.fillStyle = topGrad;
    ctx.fill();
    ctx.strokeStyle = "#888";
    ctx.lineWidth = 2;
    ctx.stroke();

    // --- Optional rim highlight ---
    ctx.beginPath();
    ctx.ellipse(size / 2, topY - 1, radiusX * 0.9, radiusY * 0.8, 0, 0, Math.PI * 2);
    ctx.strokeStyle = "rgba(255,255,255,0.15)";
    ctx.lineWidth = 1.5;
    ctx.stroke();

    // --- Winner gold ring overlay ---
    if (isWinner) {
      const ringGrad = ctx.createLinearGradient(0, 0, 0, size);
      ringGrad.addColorStop(0, "#ffd700");
      ringGrad.addColorStop(0.5, "#ffec8b");
      ringGrad.addColorStop(1, "#b8860b");

      ctx.beginPath();
      ctx.ellipse(size / 2, topY, radiusX + 3, radiusY + 3, 0, 0, Math.PI * 2);
      ctx.lineWidth = 5;
      ctx.strokeStyle = ringGrad;
      ctx.stroke();
    }

    // --- Apply favicon ---
    const favicon = document.getElementById("favicon");
    favicon.href = canvas.toDataURL("image/png");
  }
};

// ==================== BOARD MANAGEMENT ====================
const board = {
  create() {
    state.game.board = [];
    
    // Clean up existing meshes
    state.scene.boardMeshes.forEach(mesh => {
      scene.remove(mesh);
      mesh.geometry.dispose();
      mesh.material.dispose();
    });
    state.scene.boardMeshes = [];
    
    // Remove frame and base
    this.removeFrame();
    
    for (let l = 0; l < CONFIG.BOARD.LAYERS; l++) {
      const layer = [];
      for (let r = 0; r < CONFIG.BOARD.SIZE; r++) {
        const row = [];
        for (let c = 0; c < CONFIG.BOARD.SIZE; c++) {
          const isDark = (r + c + l) % 2 === 0;
          const material = new THREE.MeshPhongMaterial({
            color: isDark ? CONFIG.COLORS.DARK_TILE : CONFIG.COLORS.LIGHT_TILE,
            transparent: true,
            opacity: 0.7
          });
          
          const tile = new THREE.Mesh(geometries.tile, material);
          tile.position.set(c, l * CONFIG.BOARD.GAP, r);
          tile.userData = { boardCoord: { l, r, c } };
          scene.add(tile);
          state.scene.boardMeshes.push(tile);
          
          row.push(null);
        }
        layer.push(row);
      }
      state.game.board.push(layer);
    }
    
    // Add frame and base in 3D mode
    if (CONFIG.VIEW_MODE === '3D') {
      this.createFrame();
    }
    
    this.updateBoardLayout();
  },
  
  createFrame() {
    const size = CONFIG.BOARD.SIZE;
    const postHeight = (CONFIG.BOARD.LAYERS - 1) * CONFIG.BOARD.GAP + 0.31;
    const postRadius = 0.15;
    const baseThickness = 0.3;
    const baseExtend = 0.5;
    
    // Create corner posts
    const postGeometry = new THREE.CylinderGeometry(postRadius, postRadius, postHeight, 16);
    const corners = [
      [-baseExtend, 0, -baseExtend],
      [size - 1 + baseExtend, 0, -baseExtend],
      [-baseExtend, 0, size - 1 + baseExtend],
      [size - 1 + baseExtend, 0, size - 1 + baseExtend]
    ];
    
    corners.forEach(([x, y, z]) => {
      const post = new THREE.Mesh(postGeometry, materials.wood);
      post.position.set(x, postHeight / 2 - 0.25, z);
      scene.add(post);
      state.scene.framePosts.push(post);
    });
    
    // Create base board
    const baseGeometry = new THREE.BoxGeometry(
      size + baseExtend * 2,
      baseThickness,
      size + baseExtend * 2
    );
    state.scene.baseBoard = new THREE.Mesh(baseGeometry, materials.wood);
    state.scene.baseBoard.position.set(
      (size - 1) / 2,
      -baseThickness / 2 - 0.1,
      (size - 1) / 2
    );
    scene.add(state.scene.baseBoard);
  },
  
  removeFrame() {
    // Remove posts
    state.scene.framePosts.forEach(post => {
      scene.remove(post);
      post.geometry.dispose();
      post.material.dispose();
    });
    state.scene.framePosts = [];
    
    // Remove base
    if (state.scene.baseBoard) {
      scene.remove(state.scene.baseBoard);
      state.scene.baseBoard.geometry.dispose();
      state.scene.baseBoard.material.dispose();
      state.scene.baseBoard = null;
    }
  },
  
  updateBoardLayout() {
    if (CONFIG.VIEW_MODE === '2D') {
      // Arrange layers side by side
      const spacing = CONFIG.BOARD.SIZE + 2;
      
      for (let l = 0; l < CONFIG.BOARD.LAYERS; l++) {
        for (let r = 0; r < CONFIG.BOARD.SIZE; r++) {
          for (let c = 0; c < CONFIG.BOARD.SIZE; c++) {
            const mesh = state.scene.boardMeshes[l * CONFIG.BOARD.SIZE * CONFIG.BOARD.SIZE + r * CONFIG.BOARD.SIZE + c];
            if (mesh) {
              mesh.position.set(c + l * spacing, 0, r);
            }
            
            // Update piece positions
            const pieceMesh = pieces.getMesh(l, r, c);
            if (pieceMesh) {
              pieceMesh.position.set(c + l * spacing, 0.15, r);
            }
          }
        }
      }
      
      // Update camera and controls
      const centerX = (CONFIG.BOARD.LAYERS - 1) * spacing / 2 + 3.5;
      controls.target.set(centerX, 0, 3.5);
      camera.position.set(centerX, 20, 3.5);
    } else {
      // 3D stacked layout
      for (let l = 0; l < CONFIG.BOARD.LAYERS; l++) {
        for (let r = 0; r < CONFIG.BOARD.SIZE; r++) {
          for (let c = 0; c < CONFIG.BOARD.SIZE; c++) {
            const mesh = state.scene.boardMeshes[l * CONFIG.BOARD.SIZE * CONFIG.BOARD.SIZE + r * CONFIG.BOARD.SIZE + c];
            if (mesh) {
              mesh.position.set(c, l * CONFIG.BOARD.GAP, r);
            }
            
            // Update piece positions
            const pieceMesh = pieces.getMesh(l, r, c);
            if (pieceMesh) {
              pieceMesh.position.set(c, l * CONFIG.BOARD.GAP + 0.15, r);
            }
          }
        }
      }
      
      // Reset camera
      controls.target.set(3.5, 0, 3.5);
      camera.position.set(8, 12, 16);
    }
    
    controls.update();
  }
};

// ==================== PIECE MANAGEMENT ====================
const pieces = {
  setup() {
    this.clearAll();
    
    // Red pieces (bottom layer)
    for (let r = 5; r < 8; r++) {
      for (let c = 0; c < 8; c++) {
        if ((r + c + 2) % 2 === 0) {
          this.create('r', CONFIG.BOARD.LAYERS - 1, r, c);
        }
      }
    }
    
    // Black pieces (top layer)
    for (let r = 0; r < 3; r++) {
      for (let c = 0; c < 8; c++) {
        if ((r + c + 2) % 2 === 0) {
          this.create('b', 0, r, c);
        }
      }
    }
    
    ui.updateSidebar();
  },
  
  create(color, l, r, c) {
    const material = color === 'r' ? materials.red : materials.black;
    const mesh = new THREE.Mesh(geometries.piece, material);
    
    // Position based on view mode
    if (CONFIG.VIEW_MODE === '2D') {
      const spacing = CONFIG.BOARD.SIZE + 2;
      mesh.position.set(c + l * spacing, 0.15, r);
    } else {
      mesh.position.set(c, l * CONFIG.BOARD.GAP + 0.15, r);
    }
    
    mesh.userData.boardCoord = { l, r, c };
    scene.add(mesh);
    
    state.game.board[l][r][c] = { c: color, king: false };
    state.scene.pieceMeshes[utils.getPieceMeshKey(l, r, c)] = mesh;
  },
  
  clearAll() {
    Object.values(state.scene.pieceMeshes).forEach(mesh => {
      this.removeKingBand(mesh);
      scene.remove(mesh);
      mesh.geometry.dispose();
      mesh.material.dispose();
    });
    state.scene.pieceMeshes = {};
  },
  
  addKingBand(mesh) {
    if (mesh.userData.kingBand) return;
    const band = new THREE.Mesh(geometries.kingBand, materials.gold);
    band.rotation.x = Math.PI / 2;
    band.position.y = 0.1;
    mesh.add(band);
    mesh.userData.kingBand = band;
  },
  
  removeKingBand(mesh) {
    if (!mesh.userData.kingBand) return;
    mesh.remove(mesh.userData.kingBand);
    mesh.userData.kingBand.geometry.dispose();
    mesh.userData.kingBand.material.dispose();
    mesh.userData.kingBand = null;
  },
  
  getMesh(l, r, c) {
    return state.scene.pieceMeshes[utils.getPieceMeshKey(l, r, c)];
  }
};

// ==================== MOVE LOGIC ====================
const moves = {
  getValidMoves(l, r, c, onlyJumps = false) {
    const piece = state.game.board[l][r][c];
    if (!piece || piece.c !== state.game.currentPlayer) return [];
    
    const validMoves = [];
    const layerOffsets = [-1, 0, 1];
    const rowOffsets = piece.king ? [-1, 0, 1] : [piece.c === 'r' ? -1 : 1, 0];
    const colOffsets = [-1, 0, 1];
    
    for (let dl of layerOffsets) {
      for (let dr of rowOffsets) {
        for (let dc of colOffsets) {
          if (dl === 0 && dr === 0 && dc === 0) continue;
          
          const nl = l + dl, nr = r + dr, nc = c + dc;
          if (!utils.inBounds(nl, nr, nc) || !utils.isValidTile(nl, nr, nc)) continue;
          
          const target = state.game.board[nl][nr][nc];
          
          // Simple move
          if (!target && !onlyJumps) {
            validMoves.push({ 
              from: { l, r, c }, 
              to: { l: nl, r: nr, c: nc }, 
              captures: [] 
            });
          }
          // Jump move
          else if (target && target.c !== piece.c) {
            const jl = nl + dl, jr = nr + dr, jc = nc + dc;
            if (utils.inBounds(jl, jr, jc) && !state.game.board[jl][jr][jc]) {
              validMoves.push({ 
                from: { l, r, c }, 
                to: { l: jl, r: jr, c: jc }, 
                captures: [{ l: nl, r: nr, c: nc }] 
              });
            }
          }
        }
      }
    }
    
    const jumpMoves = validMoves.filter(m => m.captures.length > 0);
    return jumpMoves.length > 0 ? jumpMoves : (onlyJumps ? [] : validMoves);
  },
  
  execute(move, sendToRemote = true, isRemote = false) {
    // Only restrict moves in multiplayer mode
    if (state.game.isMultiplayer && !isRemote && 
        state.game.currentPlayer !== state.game.myColor) return;
    
    const { from, to } = move;
    const piece = state.game.board[from.l][from.r][from.c];
    if (!piece) return;
    
    // Save for undo
    const undoEntry = {
      from: { ...from },
      to: { ...to },
      piece: { ...piece },
      captured: move.captures.map(cap => {
        const cp = state.game.board[cap.l][cap.r][cap.c];
        return cp ? { color: cp.c, king: cp.king, l: cap.l, r: cap.r, c: cap.c } : null;
      }).filter(Boolean)
    };
    state.game.moveHistory.push(undoEntry);
    
    // Check for king promotion
    if (piece.c === 'r' && to.l === 0 && to.r === 0 && !piece.king) {
      piece.king = true;
      dom.sfx.king.currentTime = 0;
      dom.sfx.king.play().catch(e => console.log('Audio play failed:', e));
    }
    if (piece.c === 'b' && to.l === CONFIG.BOARD.LAYERS - 1 && to.r === 7 && !piece.king) {
      piece.king = true;
      dom.sfx.king.currentTime = 0;
      dom.sfx.king.play().catch(e => console.log('Audio play failed:', e));
    }
    
    const mesh = pieces.getMesh(from.l, from.r, from.c);
    if (piece.king && mesh && !mesh.userData.kingBand) {
      pieces.addKingBand(mesh);
    }
    
    // Move piece
    state.game.board[to.l][to.r][to.c] = piece;
    state.game.board[from.l][from.r][from.c] = null;
    
    // Remove captured pieces
    move.captures.forEach(cap => {
      const capMesh = pieces.getMesh(cap.l, cap.r, cap.c);
      if (capMesh) {
        pieces.removeKingBand(capMesh);
        scene.remove(capMesh);
        capMesh.geometry.dispose();
        capMesh.material.dispose();
        delete state.scene.pieceMeshes[utils.getPieceMeshKey(cap.l, cap.r, cap.c)];
        state.game.board[cap.l][cap.r][cap.c] = null;
      }
    });
    
    // Play sound effect
    if (move.captures.length > 0) {
      dom.sfx.capture.currentTime = 0;
      dom.sfx.capture.play().catch(e => console.log('Audio play failed:', e));
    } else {
      dom.sfx.move.currentTime = 0;
      dom.sfx.move.play().catch(e => console.log('Audio play failed:', e));
    }
    
    // Update mesh position
    if (mesh) {
      if (CONFIG.VIEW_MODE === '2D') {
        const spacing = CONFIG.BOARD.SIZE + 2;
        mesh.position.set(to.c + to.l * spacing, 0.15, to.r);
      } else {
        mesh.position.set(to.c, to.l * CONFIG.BOARD.GAP + 0.15, to.r);
      }
      mesh.userData.boardCoord = { ...to };
      delete state.scene.pieceMeshes[utils.getPieceMeshKey(from.l, from.r, from.c)];
      state.scene.pieceMeshes[utils.getPieceMeshKey(to.l, to.r, to.c)] = mesh;
    }

    visual.clearHighlights();
    
    // Check for continued jumps
    const furtherJumps = this.getValidMoves(to.l, to.r, to.c, true);
    if (furtherJumps.length > 0 && move.captures.length > 0) {
      state.game.mustContinueJump = true;
      state.game.selectedPiece = { ...to };
      visual.highlightPiece(to.l, to.r, to.c);
    } else {
      state.game.mustContinueJump = false;
      state.game.selectedPiece = null;
      
      if (game.checkWin(isRemote)) return;
      
      state.game.currentPlayer = state.game.currentPlayer === 'r' ? 'b' : 'r';
    }
    
    ui.updateSidebar();
    
    // Send to opponent
    if (state.game.isMultiplayer && sendToRemote && !isRemote) {
      network.sendMove(move, state.game.currentPlayer);
    }
  },
  
  undo() {
    if (state.game.moveHistory.length === 0) return;
    
    const last = state.game.moveHistory.pop();
    const mesh = pieces.getMesh(last.to.l, last.to.r, last.to.c);
    
    if (mesh) {
      state.game.board[last.from.l][last.from.r][last.from.c] = last.piece;
      state.game.board[last.to.l][last.to.r][last.to.c] = null;
      
      if (CONFIG.VIEW_MODE === '2D') {
        const spacing = CONFIG.BOARD.SIZE + 2;
        mesh.position.set(last.from.c + last.from.l * spacing, 0.15, last.from.r);
      } else {
        mesh.position.set(last.from.c, last.from.l * CONFIG.BOARD.GAP + 0.15, last.from.r);
      }
      
      mesh.userData.boardCoord = { ...last.from };
      delete state.scene.pieceMeshes[utils.getPieceMeshKey(last.to.l, last.to.r, last.to.c)];
      state.scene.pieceMeshes[utils.getPieceMeshKey(last.from.l, last.from.r, last.from.c)] = mesh;
      
      if (last.piece.king) pieces.addKingBand(mesh);
      else pieces.removeKingBand(mesh);
    }
    
    // Restore captured pieces
    last.captured.forEach(cap => {
      const material = cap.color === 'r' ? materials.red : materials.black;
      const capMesh = new THREE.Mesh(geometries.piece, material);
      
      if (CONFIG.VIEW_MODE === '2D') {
        const spacing = CONFIG.BOARD.SIZE + 2;
        capMesh.position.set(cap.c + cap.l * spacing, 0.15, cap.r);
      } else {
        capMesh.position.set(cap.c, cap.l * CONFIG.BOARD.GAP + 0.15, cap.r);
      }
      
      capMesh.userData.boardCoord = { l: cap.l, r: cap.r, c: cap.c };
      scene.add(capMesh);
      state.game.board[cap.l][cap.r][cap.c] = { c: cap.color, king: cap.king };
      if (cap.king) pieces.addKingBand(capMesh);
      state.scene.pieceMeshes[utils.getPieceMeshKey(cap.l, cap.r, cap.c)] = capMesh;
    });
    
    visual.clearHighlights();
    state.game.mustContinueJump = false;
    state.game.selectedPiece = null;
    state.game.currentPlayer = state.game.currentPlayer === 'r' ? 'b' : 'r';
    ui.updateSidebar();
  }
};

// ==================== VISUAL EFFECTS ====================
const visual = {
  clearHighlights() {
    if (state.scene.outlineMesh) {
      scene.remove(state.scene.outlineMesh);
      state.scene.outlineMesh.geometry.dispose();
      state.scene.outlineMesh.material.dispose();
      state.scene.outlineMesh = null;
    }
    
    state.scene.virtualMoves.forEach(vm => {
      scene.remove(vm);
      vm.geometry.dispose();
      vm.material.dispose();
    });
    state.scene.virtualMoves = [];
  },
  
  highlightPiece(l, r, c) {
    this.clearHighlights();
    
    const mesh = pieces.getMesh(l, r, c);
    if (!mesh) return;
    
    const edges = new THREE.EdgesGeometry(mesh.geometry);
    state.scene.outlineMesh = new THREE.LineSegments(
      edges,
      new THREE.LineBasicMaterial({ color: CONFIG.COLORS.HIGHLIGHT, linewidth: 2 })
    );
    state.scene.outlineMesh.position.copy(mesh.position);
    state.scene.outlineMesh.rotation.copy(mesh.rotation);
    scene.add(state.scene.outlineMesh);
    
    const validMoves = moves.getValidMoves(l, r, c, state.game.mustContinueJump);
    validMoves.forEach(move => {
      const vm = new THREE.Mesh(geometries.validMove, materials.validMove);
      
      if (CONFIG.VIEW_MODE === '2D') {
        const spacing = CONFIG.BOARD.SIZE + 2;
        vm.position.set(move.to.c + move.to.l * spacing, 0.15, move.to.r);
      } else {
        vm.position.set(move.to.c, move.to.l * CONFIG.BOARD.GAP + 0.15, move.to.r);
      }
      
      vm.userData.move = move;
      scene.add(vm);
      state.scene.virtualMoves.push(vm);
    });
  }
};

// ==================== GAME LOGIC ====================
const game = {
  reset() {
    state.game.currentPlayer = 'r';
    state.game.mustContinueJump = false;
    state.game.selectedPiece = null;
    state.game.moveHistory = [];
    pieces.clearAll();
    visual.clearHighlights();
    board.create();
    pieces.setup();
  },
  
  checkWin(isRemote = false) {
    let redCount = 0, blackCount = 0;
    
    for (let l = 0; l < CONFIG.BOARD.LAYERS; l++) {
      for (let r = 0; r < CONFIG.BOARD.SIZE; r++) {
        for (let c = 0; c < CONFIG.BOARD.SIZE; c++) {
          const p = state.game.board[l][r][c];
          if (p) {
            if (p.c === 'r') redCount++;
            else blackCount++;
          }
        }
      }
    }
    
    ui.updateSidebar();
    
    if (redCount === 0) {
      this.showWinScreen('b', isRemote);
      if (state.game.isMultiplayer && !isRemote) network.sendWin('b');
      return true;
    }
    
    if (blackCount === 0) {
      this.showWinScreen('r', isRemote);
      if (state.game.isMultiplayer && !isRemote) network.sendWin('r');
      return true;
    }
    
    return false;
  },
  
  showWinScreen(winner, isRemote = false) {
    let text;
    if (state.game.isMultiplayer) {
      text = winner === state.game.myColor ? "You Won! 🎉" : `${state.player.opponentName} Wins! 🏆`;
    } else {
      text = winner === 'r' ? "Red Wins!" : "Black Wins!";
    }
    
    if (winner === 'r') {
      utils.setFavicon('red', true);
    } else {
      utils.setFavicon('black', true);
    }
    
    // Play win sound
    dom.sfx.win.currentTime = 0;
    dom.sfx.win.play().catch(e => console.log('Audio play failed:', e));
    
    dom.winText.textContent = text;
    utils.showModal('win');
    dom.undoBtn.style.display = 'none';
  }
};

// ==================== UI ====================
const ui = {
  updateNames() {
    // Set player names
    const redName = (
        state.game.myColor === 'r' 
        ? ( state.player.displayName ? `${state.player.displayName} (You)` : null)
        : state.player.opponentName
      ) || "Red";
    const blackName = (
        state.game.myColor === 'b'
        ? ( state.player.displayName ? `${state.player.displayName} (You)` : null)
        : state.player.opponentName
      ) || "Black";

    dom.redName.textContent = redName;
    dom.blackName.textContent = blackName;
  },

  updateSidebar() {
    this.updateNames();

    // Highlight the active player
    dom.redProfile.classList.toggle('active', state.game.currentPlayer === 'r');
    dom.blackProfile.classList.toggle('active', state.game.currentPlayer === 'b');
    
    if (state.game.currentPlayer === 'r') {
      utils.setFavicon('red');
    } else {
      utils.setFavicon('black');
    }
  },
  
  resetNewGameButtons() {
    [dom.newGameBtn, dom.buttons.winNewGame].forEach(btn => {
      btn.disabled = false;
      btn.style.backgroundColor = '';
      btn.textContent = 'New Game';
    });
  },
  
  showNewGamePrompt() {
    dom.newGameBtn.style.backgroundColor = '#d9534f';
    dom.newGameBtn.textContent = 'Opponent wants new game - Click to confirm';
    dom.newGameBtn.disabled = false;
    state.network.isRespondingToNewGame = true;
    
    setTimeout(() => {
      if (state.network.isRespondingToNewGame) {
        state.network.isRespondingToNewGame = false;
        dom.newGameBtn.textContent = 'New Game';
        dom.newGameBtn.style.backgroundColor = '';
        dom.newGameBtn.disabled = false;
      }
    }, 15000);
  }
};

// ==================== NETWORK ====================
const network = {
  connectWebSocket() {
    state.network.ws = new WebSocket(CONFIG.WS_URL);
    
    state.network.ws.addEventListener('open', () => {
      console.log('WebSocket connected');
    });
    
    state.network.ws.addEventListener('message', async msg => {
      const data = JSON.parse(msg.data);
      await this.handleMessage(data);
    });
  },
  
  async handleMessage(data) {
    switch (data.type) {
      case 'ice':
        await this.handleIceCandidate(data.candidate);
        break;
        
      case 'opponentRequestedNewGame':
        if (data.reqId && data.reqId === state.network.lastNewGameReqId) return;
        ui.showNewGamePrompt();
        break;
        
      case 'startNewGame':
        state.network.isAutoResetting = true;
        dom.newGameBtn.disabled = false;
        dom.newGameBtn.style.backgroundColor = '';
        dom.newGameBtn.textContent = 'New Game';
        state.network.lastNewGameReqId = null;
        game.reset();
        ui.resetNewGameButtons();
        setTimeout(() => { state.network.isAutoResetting = false; }, 500);
        break;
        
      case 'opponentDisconnected':
        utils.showModal('disconnected');
        setTimeout(() => {
          utils.showModal('startup');
          dom.undoBtn.style.display = 'block';
          state.game.isMultiplayer = false;
          game.reset();
        }, 5000);
        break;

      case 'roomCreated':
        // Server sent back the new private room code
        state.network.roomId = data.roomId;
        utils.showModal('waiting');
        dom.waitingCode.textContent = `Join Code: ${data.roomId}`;
        break;

      case 'waitingForOpponent':
        // Player is waiting in queue or room
        utils.showModal('waiting');
        dom.waitingCode.textContent = '';
        break;
      
      case 'matchFound':
      case 'startGame':
        // Match found or opponent joined — start the game
        utils.hideAllModals();
        state.game.isMultiplayer = true;
        state.game.myColor = data.isCaller ? 'r' : 'b';
        ui.updateNames()
        game.reset();
        
        // 🟢 Store names
        state.player.opponentName = data.opponentName || "Opponent";
        ui.updateNames();
        
        // Begin WebRTC connection setup
        state.network.isCaller = data.isCaller || false;
        state.network.roomId = data.roomId;
        network.setupPeerConnection();
        break;

      case 'offer':
        await state.network.pc.setRemoteDescription(new RTCSessionDescription(data.offer));
        const answer = await state.network.pc.createAnswer();
        await state.network.pc.setLocalDescription(answer);
        state.network.ws.send(JSON.stringify({
          type: 'answer',
          answer,
          roomId: state.network.roomId
        }));
        break;

      case 'answer':
        await state.network.pc.setRemoteDescription(new RTCSessionDescription(data.answer));
        await network.flushPendingIceCandidates();
        break;
      
      case 'roomInvalid':
        alert(`Room "${data.roomId}" does not exist or has been closed.`);
        utils.showModal('webrtc'); // back to join/create modal
        break;

      case 'roomFull':
        alert(`Room "${data.roomId}" is already full.`);
        utils.showModal('webrtc');
        break;
    }
  },

  setupPeerConnection() {
    if (state.network.pc) return;
    
    state.network.pc = new RTCPeerConnection({
      iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
    });
    
    state.network.pc.onicecandidate = e => {
      if (e.candidate) {
        state.network.ws.send(JSON.stringify({ 
          type: 'ice', 
          candidate: e.candidate, 
          roomId: state.network.roomId 
        }));
      }
    };
    
    state.network.pc.ondatachannel = event => {
      state.network.dataChannel = event.channel;
      this.setupDataChannel();
    };
    
    if (state.network.isCaller) {
      state.network.dataChannel = state.network.pc.createDataChannel('game');
      this.setupDataChannel();
      
      state.network.pc.createOffer()
        .then(offer => state.network.pc.setLocalDescription(offer))
        .then(() => {
          state.network.ws.send(JSON.stringify({ 
            type: 'offer', 
            offer: state.network.pc.localDescription, 
            roomId: state.network.roomId 
          }));
        });
    }
  },
  
  async handleIceCandidate(candidate) {
    if (!candidate) return;
    if (!state.network.pc || !state.network.pc.remoteDescription) {
      state.network.pendingIceCandidates.push(candidate);
      return;
    }
    try {
      await state.network.pc.addIceCandidate(candidate);
    } catch (err) {
      console.error('Error adding ICE candidate:', err);
    }
  },
  
  async flushPendingIceCandidates() {
    if (!state.network.pc || !state.network.pendingIceCandidates.length) return;
    
    for (const candidate of state.network.pendingIceCandidates) {
      try {
        await state.network.pc.addIceCandidate(candidate);
      } catch (err) {
        console.error('Error flushing ICE candidate:', err);
      }
    }
    state.network.pendingIceCandidates = [];
  },
  
  setupDataChannel() {
    state.network.dataChannel.onopen = () => {
      state.network.dataChannelReady = true;
      while (state.network.dataChannelQueue.length > 0) {
        state.network.dataChannel.send(state.network.dataChannelQueue.shift());
      }
    };
    
    state.network.dataChannel.onmessage = e => {
      const payload = JSON.parse(e.data);
      
      if (payload.type === 'move') {
        moves.execute(payload.move, false, true);
        if (!game.checkWin(true)) {
          state.game.currentPlayer = payload.nextTurn;
        }
        ui.updateSidebar();
      } else if (payload.type === 'win') {
        game.showWinScreen(payload.winner, true);
        state.game.currentPlayer = null;
      }
    };
    
    state.network.dataChannel.onclose = () => {
      state.network.dataChannelReady = false;
    };
  },
  
  sendMove(move, nextTurn) {
    const payload = { type: 'move', move, nextTurn };
    const msg = JSON.stringify(payload);
    
    if (state.network.dataChannel && state.network.dataChannelReady) {
      state.network.dataChannel.send(msg);
    } else {
      state.network.dataChannelQueue.push(msg);
    }
  },
  
  sendWin(winner) {
    if (state.network.dataChannel && state.network.dataChannelReady) {
      state.network.dataChannel.send(JSON.stringify({ type: 'win', winner }));
    }
  },
  
  requestNewGame(button = dom.newGameBtn) {
    if (state.network.isAutoResetting) return;
    
    if (state.network.isRespondingToNewGame) {
      if (state.network.ws && state.network.ws.readyState === WebSocket.OPEN) {
        state.network.ws.send(JSON.stringify({ 
          type: 'readyForNewGame', 
          roomId: state.network.roomId 
        }));
      }
      button.textContent = 'Confirming...';
      button.disabled = true;
      button.style.backgroundColor = '#888';
      state.network.isRespondingToNewGame = false;
      return;
    }
    
    if (state.game.isMultiplayer && state.network.ws && 
        state.network.ws.readyState === WebSocket.OPEN) {
      const reqId = Math.random().toString(36).substring(2, 8);
      state.network.lastNewGameReqId = reqId;
      
      state.network.ws.send(JSON.stringify({ 
        type: 'readyForNewGame', 
        roomId: state.network.roomId, 
        reqId 
      }));
      
      button.style.backgroundColor = '#888';
      button.textContent = 'Waiting for opponent...';
      button.disabled = true;
    } else {
      game.reset();
    }
  }
};

// ==================== INTERACTION ====================
const raycaster = new THREE.Raycaster();
const pointer = new THREE.Vector2();

function onClick(event) {
  // Only restrict clicks in multiplayer mode
  if (state.game.isMultiplayer && state.game.currentPlayer !== state.game.myColor) return;
  
  const rect = dom.viewport.getBoundingClientRect();
  pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
  pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
  
  raycaster.setFromCamera(pointer, camera);
  const intersects = raycaster.intersectObjects(scene.children, true);
  
  if (intersects.length === 0) return;
  
  for (const hit of intersects) {
    const obj = hit.object;
    
    // Click on valid move indicator
    if (obj.userData.move) {
      moves.execute(obj.userData.move);
      return;
    }
    
    // Click on piece
    if (obj.userData.boardCoord) {
      const { l, r, c } = obj.userData.boardCoord;
      
      if (state.game.mustContinueJump && 
          state.game.selectedPiece && 
          (state.game.selectedPiece.l !== l || 
           state.game.selectedPiece.r !== r || 
           state.game.selectedPiece.c !== c)) {
        return;
      }
      
      const piece = state.game.board[l][r][c];
      if (!piece || piece.c !== state.game.currentPlayer) return;
      
      if (state.game.selectedPiece && 
          state.game.selectedPiece.l === l && 
          state.game.selectedPiece.r === r && 
          state.game.selectedPiece.c === c) {
        state.game.selectedPiece = null;
        visual.clearHighlights();
      } else {
        state.game.selectedPiece = { l, r, c };
        visual.highlightPiece(l, r, c);
      }
      return;
    }
  }
}

// ==================== EVENT LISTENERS ====================
dom.viewport.addEventListener('pointerdown', onClick);

window.addEventListener('resize', () => {
  camera.aspect = dom.viewport.clientWidth / dom.viewport.clientHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(dom.viewport.clientWidth, dom.viewport.clientHeight);
});

window.addEventListener('load', () => {
  utils.setFavicon(state.game?.currentPlayer === 'b' ? 'black' : 'red');
});

// Menu buttons
dom.buttons.local.addEventListener('click', () => {
  utils.hideAllModals();
  dom.undoBtn.style.display = 'block';
  state.game.isMultiplayer = false;
  state.game.currentPlayer = 'r';
});

dom.buttons.webrtc.addEventListener('click', () => {
  utils.showModal('webrtc');
  dom.undoBtn.style.display = 'none';
  state.game.isMultiplayer = true;
});

dom.buttons.back.addEventListener('click', () => {
  utils.showModal('startup');
});

dom.buttons.public.addEventListener('click', () => {
  const name = dom.buttons.displayName.value.trim();
  if (!name) return alert('Please enter a Name/Handle');
  state.player.displayName = name;
  utils.showModal('waiting');
  dom.waitingCode.textContent = '';
  network.connectWebSocket();
  state.network.ws.addEventListener('open', () => {
    state.network.ws.send(JSON.stringify({ type: 'joinPublic', displayName: name }));
  });
});

dom.buttons.createPrivate.addEventListener('click', () => {
  const name = dom.buttons.displayName.value.trim();
  if (!name) return alert('Please enter a Name/Handle');
  state.player.displayName = name;
  const id = Math.random().toString(36).substring(2, 8);
  
  const joinUrl = `${window.location.origin}${window.location.pathname}?room=${id}`;
  
  dom.waitingCode.innerHTML = `
    Join Code:
    <br><br>
    <span id="joinCode">${id}</span>
    <br><br>
    <button id="copyCode">Copy Invite Code</button>
    <button id="copyLink">Copy Invite URL</button>
    <br>
    <span id="copyStatus" style="color:#0f0; margin-left:10px; display:none;">✅ Copied!</span>
  `;
  
  const copyCode = document.getElementById('copyCode');
  const copyLink = document.getElementById('copyLink');
  const copyStatus = document.getElementById('copyStatus');
  
  copyCode.addEventListener('click', async () => {
    try {
      await navigator.clipboard.writeText(id);
      copyStatus.style.display = 'inline';
      setTimeout(() => (copyStatus.style.display = 'none'), 2000);
    } catch (err) {
      console.error('Clipboard copy failed:', err);
      alert('Could not copy the link. Please copy the Code instead.');
    }
  });
  
  copyLink.addEventListener('click', async () => {
    try {
      await navigator.clipboard.writeText(joinUrl);
      copyStatus.style.display = 'inline';
      setTimeout(() => (copyStatus.style.display = 'none'), 2000);
    } catch (err) {
      console.error('Clipboard copy failed:', err);
      alert('Could not copy the link. Please copy the Code instead.');
    }
  });
  
  utils.showModal('waiting');
  network.connectWebSocket();
  state.network.ws.addEventListener('open', () => {
    state.network.ws.send(JSON.stringify({ type: 'createPrivate', roomId: id, displayName: name }));
  });
});

dom.buttons.joinPrivate.addEventListener('click', () => {
  const name = dom.buttons.displayName.value.trim();
  if (!name) return alert('Please enter a Name/Handle');
  state.player.displayName = name;
  const id = dom.buttons.privateInput.value.trim();
  if (!id) return alert('Please enter a Game ID');
  dom.waitingCode.textContent = `Joining Room: ${id}`
  utils.showModal('waiting');
  network.connectWebSocket();
  state.network.ws.addEventListener('open', () => {
    state.network.ws.send(JSON.stringify({ type: 'joinPrivate', roomId: id, displayName: name }));
  });
});

dom.newGameBtn.addEventListener('click', () => {
  network.requestNewGame(dom.newGameBtn);
});

dom.undoBtn.addEventListener('click', () => {
  moves.undo();
});

dom.buttons.winNewGame.addEventListener('click', () => {
  utils.hideAllModals();
  network.requestNewGame(dom.buttons.winNewGame);
});

dom.buttons.winMainMenu.addEventListener('click', () => {
  utils.showModal('startup');
  dom.undoBtn.style.display = 'block';
  ui.resetNewGameButtons();
  state.game.isMultiplayer = false;
  state.game.currentPlayer = 'r';
  game.reset();
});

// Private modal navigation
dom.buttons.private.addEventListener('click', () => {
  utils.showModal('private');
});

dom.buttons.backToOnline.addEventListener('click', () => {
  utils.showModal('webrtc');
});

// Help overlay
dom.helpButton.addEventListener('click', () => {
  dom.helpOverlay.classList.add('active');
});

dom.helpClose.addEventListener('click', () => {
  dom.helpOverlay.classList.remove('active');
});

dom.helpOverlay.addEventListener('click', (e) => {
  if (e.target === dom.helpOverlay) {
    dom.helpOverlay.classList.remove('active');
  }
});

// Detect mobile for help text
function updateHelpControls() {
  const isMobile = window.innerWidth <= 700 || 'ontouchstart' in window;
  dom.desktopControls.style.display = isMobile ? 'none' : 'block';
  dom.mobileControls.style.display = isMobile ? 'block' : 'none';
}

window.addEventListener('resize', updateHelpControls);
updateHelpControls();

// View toggle
dom.viewToggle.addEventListener('click', () => {
  if (CONFIG.VIEW_MODE === '3D') {
    CONFIG.VIEW_MODE = '2D';
    board.removeFrame();
    // Disable rotation in 2D
    controls.enableRotate = false;
  } else {
    CONFIG.VIEW_MODE = '3D';
    board.createFrame();
    // Re-enable rotation in 3D
    controls.enableRotate = true;
  }
  board.updateBoardLayout();
  visual.clearHighlights();
});

// ==================== AUTO-JOIN IF ?room=XYZ IN URL ====================
const params = new URLSearchParams(window.location.search);
const autoRoom = params.get('room');

if (autoRoom) {
  utils.showModal('webrtc');
  dom.undoBtn.style.display = 'none';
  state.game.isMultiplayer = true;

  // Small delay to ensure DOM is ready
  setTimeout(() => {
    const name = prompt("Enter your display name to join the game:")?.trim();
    if (!name) return alert('Name is required to join the game.');

    state.player.displayName = name;
    dom.waitingCode.textContent = `Joining Room: ${autoRoom}`;
    utils.showModal('waiting');

    network.connectWebSocket();
    state.network.ws.addEventListener('open', () => {
      state.network.ws.send(JSON.stringify({
        type: 'joinPrivate',
        roomId: autoRoom,
        displayName: name
      }));
    });
  }, 300);
}

// ==================== ANIMATION LOOP ====================
function animate() {
  requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}

// ==================== INITIALIZATION ====================
board.create();
pieces.setup();
animate();
</script>
</body>
</html>


